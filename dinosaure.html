<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-04-30 lun. 22:47 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Calascibetta" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://dinosaure.github.io/org/org.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org49372ab">1. <span class="done DONE">DONE</span> extraire rabin d'ocaml-git et en faire une librairie (duff)</a></li>
<li><a href="#org9bf65cb">2. <span class="done DONE">DONE</span> Faire un README.md de duff</a></li>
<li><a href="#org39fe337">3. <span class="done DONE">DONE</span> Faire une release de duff</a></li>
<li><a href="#org99502c3">4. <span class="done DONE">DONE</span> Implémenter un fuzzer pour duff</a></li>
<li><a href="#org0530aac">5. <span class="done DONE">DONE</span> Faire un binaire de duff</a></li>
<li><a href="#orgf1d0616">6. <span class="done DONE">DONE</span> faire le README.md de radis</a>
<ul>
<li><a href="#orgab4f5eb">6.1. Corriger les fautes en anglais</a></li>
</ul>
</li>
<li><a href="#orgb1b9851">7. <span class="todo TODO">TODO</span> Faire une release de radis</a></li>
<li><a href="#orgdeb1b45">8. <span class="done DONE">DONE</span> Implémenter la fonction <code>remove</code></a></li>
<li><a href="#org26c19dd">9. <span class="done DONE">DONE</span> Faire en sorte que <code>radis</code> respect <code>Map.S</code></a></li>
<li><a href="#org356d723">10. <span class="todo TODO">TODO</span> Optimisation de <code>radis</code></a></li>
<li><a href="#orgfd530f6">11. <span class="todo TODO">TODO</span> Implémenter des tests sur <code>radis</code></a></li>
<li><a href="#orgbe40f04">12. <span class="done DONE">DONE</span> extraire RFC1951 de decompress</a>
<ul>
<li><a href="#org53546f0">12.1. <span class="todo TODO">TODO</span> [ ] contraindre decompress d'utiliser <code>camlzip.1.07</code></a></li>
</ul>
</li>
<li><a href="#org27db59d">13. <span class="done DONE">DONE</span> fixer Decompress.Inflate avec un random input</a></li>
<li><a href="#org0c4d83b">14. <span class="done DONE">DONE</span> Vérifier RFC1951 sur les derniers bytes</a></li>
<li><a href="#orgec8874b">15. <span class="done DONE">DONE</span> Vérifier le <i>header</i> dans decompress</a></li>
<li><a href="#orgc87e927">16. Fuzzer encore</a>
<ul>
<li><a href="#org345a7e3">16.1. Il faut attendre la PR de Gabriel pour faire ce travail.</a></li>
</ul>
</li>
<li><a href="#org6ec987d">17. <span class="todo TODO">TODO</span> Optimiser ocaml-git</a>
<ul>
<li><a href="#org1ffe2e5">17.1. <span class="done DONE">DONE</span> Utiliser <code>Hashtbl</code> à la place de <code>Map</code></a></li>
<li><a href="#orgad17aa0">17.2. <span class="done DONE">DONE</span> Revoir <code>Pack_info</code> et réutiliser son code pour l'analyze d'un flux PACK</a></li>
<li><a href="#org9c1ca87">17.3. <span class="done DONE">DONE</span> Optimization des fichiers PACK déjà disponibles dans le dépôts</a></li>
</ul>
</li>
<li><a href="#org6d024ed">18. <span class="todo TODO">TODO</span> Trouver pourquoi on avait pas trouver le bug par rapport aux \000 dans les noms dans les trees</a></li>
<li><a href="#org425eb28">19. <span class="todo TODO">TODO</span> Extraire la partie qui sérialize une seule <i>entry</i> dans l'implémentation du PACK</a></li>
<li><a href="#org9445d7d">20. <span class="todo TODO">TODO</span> Permettre d'encoder une seule <i>entry</i> pour <code>wodan</code></a></li>
<li><a href="#org03bbf61">21. <span class="todo TODO">TODO</span> Faire le serveur</a></li>
<li><a href="#orgb7fae00">22. <span class="todo TODO">TODO</span> Regarder mirage-lambda et y participer</a></li>
<li><a href="#org5bdffc3">23. Passer Mr. MIME à Angstrom</a></li>
<li><a href="#org5d14f78">24. Gérer l'<i>encoding</i> des e-mails (normaliser un <i>encoding</i> vers de l'UTF-8)</a>
<ul>
<li><a href="#orgd6dfa14">24.1. Faire un outil d'importation des tables de mappings entre <i>charset</i> et unicode</a></li>
</ul>
</li>
<li><a href="#org5b1c1d0">25. <span class="todo TODO">TODO</span> Ce forcer à utiliser org-mode (2 mois de tests)</a></li>
<li><a href="#orgdfb421a">26. <span class="todo TODO">TODO</span> Avoir deux serveur uDNS (un sur intel et un sur arm) et configurer son PC sur ces serveur</a></li>
<li><a href="#orgbd82e28">27. Implémenter Lwt<sub>sequence</sub> avec CFML ou Why3 pour ocaml-tcpip</a></li>
<li><a href="#orgabb8858">28. <span class="done DONE">DONE</span> Exporter les parsers d'Emile</a></li>
<li><a href="#org7f48f79">29. <span class="done DONE">DONE</span> Meilleur documentation pour Emile</a></li>
<li><a href="#org54f09cf">30. <span class="todo TODO">TODO</span> Fixer <code>quoted_string</code> (Emile)</a></li>
<li><a href="#org2beac92">31. <span class="done DONE">DONE</span> Faire une issue sur bigstringaf pour connaitre et déblayer la situation avec <code>Cstruct</code> spécifiquement</a>
<ul>
<li><a href="#org57dd53d">31.1. Implémentation C (utilisant <code>memcpy</code> et/ou <code>memmove</code>).</a></li>
<li><a href="#org95c9790">31.2. Implémentation en OCaml</a></li>
<li><a href="#orga9d268f">31.3. Bound-check</a></li>
<li><a href="#org50031ff">31.4. Disgression</a></li>
<li><a href="#org6f0688f">31.5. Conclusion</a></li>
</ul>
</li>
<li><a href="#orgee9fdf9">32. <span class="todo TODO">TODO</span> refaire <code>callypige</code> <b>URGENT</b></a></li>
</ul>
</div>
</div>

<div id="outline-container-org49372ab" class="outline-2">
<h2 id="org49372ab"><span class="section-number-2">1</span> <span class="done DONE">DONE</span> extraire rabin d'ocaml-git et en faire une librairie (duff)</h2>
<div class="outline-text-2" id="text-1">
</div>
</div>
<div id="outline-container-org9bf65cb" class="outline-2">
<h2 id="org9bf65cb"><span class="section-number-2">2</span> <span class="done DONE">DONE</span> Faire un README.md de duff</h2>
<div class="outline-text-2" id="text-2">
</div>
</div>
<div id="outline-container-org39fe337" class="outline-2">
<h2 id="org39fe337"><span class="section-number-2">3</span> <span class="done DONE">DONE</span> Faire une release de duff</h2>
<div class="outline-text-2" id="text-3">
</div>
</div>
<div id="outline-container-org99502c3" class="outline-2">
<h2 id="org99502c3"><span class="section-number-2">4</span> <span class="done DONE">DONE</span> Implémenter un fuzzer pour duff</h2>
<div class="outline-text-2" id="text-4">
</div>
</div>
<div id="outline-container-org0530aac" class="outline-2">
<h2 id="org0530aac"><span class="section-number-2">5</span> <span class="done DONE">DONE</span> Faire un binaire de duff</h2>
<div class="outline-text-2" id="text-5">
<p>
Le fuzzer est lancer sur 163.172.129.132.
</p>
</div>
</div>

<div id="outline-container-orgf1d0616" class="outline-2">
<h2 id="orgf1d0616"><span class="section-number-2">6</span> <span class="done DONE">DONE</span> faire le README.md de radis</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgab4f5eb" class="outline-3">
<h3 id="orgab4f5eb"><span class="section-number-3">6.1</span> Corriger les fautes en anglais</h3>
</div>
</div>
<div id="outline-container-orgb1b9851" class="outline-2">
<h2 id="orgb1b9851"><span class="section-number-2">7</span> <span class="todo TODO">TODO</span> Faire une release de radis</h2>
<div class="outline-text-2" id="text-7">
<p>
Il s'agit de regarder surtout le licence et il semble qu'elle soit soumis à la
LGPL 2.1.
</p>
</div>
</div>

<div id="outline-container-orgdeb1b45" class="outline-2">
<h2 id="orgdeb1b45"><span class="section-number-2">8</span> <span class="done DONE">DONE</span> Implémenter la fonction <code>remove</code></h2>
<div class="outline-text-2" id="text-8">
<p>
Son implémentation est faite avec un trick sur les exceptions. Bon, il faut
savoir que Radis n'a pas été fait pour enlever des éléments. La solution est
donc de lever une exception <code>Empty</code> quand on trouve `L (k, v) when k = key` et
sur les noeuds, on rattrape cet exception pour affiner l'arbre:
</p>
<ul class="org-ul">
<li>B (l, r, _, _) -&gt; l ou r (en fonction de la direction)</li>
<li>T (m, k, v)    -&gt; L (k, v)</li>
</ul>

<p>
C'est pas propre mais bon, il y a le <code>remove</code>.
</p>
</div>
</div>

<div id="outline-container-org26c19dd" class="outline-2">
<h2 id="org26c19dd"><span class="section-number-2">9</span> <span class="done DONE">DONE</span> Faire en sorte que <code>radis</code> respect <code>Map.S</code></h2>
<div class="outline-text-2" id="text-9">
</div>
</div>
<div id="outline-container-org356d723" class="outline-2">
<h2 id="org356d723"><span class="section-number-2">10</span> <span class="todo TODO">TODO</span> Optimisation de <code>radis</code></h2>
<div class="outline-text-2" id="text-10">
<p>
Sur ce plan, j'ai changé la fonction <code>compare</code> qui, à mon sens, fait le plus
gros du travail. On fait d'abord une comparaison sur les tailles des chaines
pour savoir si on doit retourner:
</p>
<ul class="org-ul">
<li>Contain (dans le cas où <code>length(a) &lt; length(b)</code>) et si le contenu est équivalent</li>
<li>Prefix  (dans le cas où <code>length(a) &gt; length(b)</code>) et si le contenu est équivalent</li>
</ul>

<p>
Dans les autres cas, on est face à <code>Inf</code> ou <code>Sup</code> (dépends des caractères)
</p>

<p>
Enfin, le dernier cas, le <i>pire</i>, c'est quand <code>a = b</code>.
</p>

<p>
L'impact ne semble pas si significatif et j'ai besoin de faire un autre
<i>benchmark</i> avec <code>Core_bench</code> pour avoir un meilleur outil de comparaison.
</p>

<p>
Cette optimisation est disponible <a href="https://github.com/dinosaure/radis/pull/1">ici</a>.
</p>
</div>
</div>

<div id="outline-container-orgfd530f6" class="outline-2">
<h2 id="orgfd530f6"><span class="section-number-2">11</span> <span class="todo TODO">TODO</span> Implémenter des tests sur <code>radis</code></h2>
</div>
<div id="outline-container-orgbe40f04" class="outline-2">
<h2 id="orgbe40f04"><span class="section-number-2">12</span> <span class="done DONE">DONE</span> extraire RFC1951 de decompress</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-org53546f0" class="outline-3">
<h3 id="org53546f0"><span class="section-number-3">12.1</span> <span class="todo TODO">TODO</span> [ ] contraindre decompress d'utiliser <code>camlzip.1.07</code></h3>
<div class="outline-text-3" id="text-12-1">
<p>
Une relecture de decompress m'amène à faire:
</p>
<ul class="org-ul">
<li>une factorisation du code comme j'ai fait dans le PACK décodeur. En effet,
<code>get_bits</code>, <code>get_byte</code>, etc. sont implémentés plusieurs fois dans le code. Il
s'agit de rajouter un argument <code>ctor</code> pour savoir sur quelle ADT utiliser.</li>
<li>Dans <code>Dictionary.inflate.get</code>, on vérifie <code>t.bits</code> pour ensuite exécuter
<code>peek_bits</code> qui fait la même vérification. C'est une duplication des
vérifications que je viens de supprimer (l'impact sur les performances devrait
être marginal cependant).</li>
<li><p>
<code>Dictionary.inflate</code> pose un gros problème. En effet, lorsqu'il s'agit de
répéter l'opération <code>loop</code> après avoir lu quelques bits avec <code>get</code>, la valeur
n'est pas repris correctement par le <code>k</code> avec ses arguments. C'est hyper
bizarre.
</p>

<p>
Bon en réalité c'était des noms de variables qui correspondaient pas à ce
qu'ils faisaient mais l'ordre était toujours bon. Genre:
</p>
<ul class="org-ul">
<li>`get (fun src dst t -&gt; loop src dst t)` // partial application</li>
<li>`get (fun v src dst t -&gt; loop v src dst t)`</li>
</ul></li>
<li>Je viens de me rendre compte la <code>window</code> peut être accessible à partir de <code>t</code>
au lieu de le passer aux fonctions. Cela peut être une optimisation car, dans
certains cas, on n'alloue pas des closures.</li>
</ul>

<p>
La PR est disponible <a href="https://github.com/mirage/decompress/pull/41">ici</a>. Le diff est pas trop lisible cependant.
</p>

<p>
L'extraction est fini, j'en ai profité pour review un petit peu le code. On a
cependant une question:
</p>

<p>
Pouvons nous utiliser l'<i>overload</i> de l'opérateur <code>.%{}</code> (et restreindre les
versions d'OCaml où Decompress compile ou utiliser directement
<code>Array.unsafe_set</code> et <code>Array.unsafe_get</code>. C'est plus une question sur la
lisibilité du code (et rien n'est prouvé au niveau des performances) qu'autre
chose. Bref, il faut regarder cela plus précisement.
</p>
</div>
</div>
</div>

<div id="outline-container-org27db59d" class="outline-2">
<h2 id="org27db59d"><span class="section-number-2">13</span> <span class="done DONE">DONE</span> fixer Decompress.Inflate avec un random input</h2>
<div class="outline-text-2" id="text-13">
<p>
Bon, il semble que le problème essentiel soit que Decompress n'est toujours pas
invalidé le contenu et attends un peu plus entant qu'<i>input</i>. Le comportement
est disponible avec:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ echo -n <span class="org-string">"a"</span> &gt; input
$ ./dpipe &lt; input &gt; /dev/null
^C
</pre>
</div>

<p>
Dans ce contexte, puisque Decompress ne vérifie pas le <i>header</i> (TODO), il
attends quelque chose. Cependant, le <i>refiller</i> retourne <code>0</code> et le considère pas
comme étant la fin du fichier - notamment parce que dans un <i>stream</i> depuis une
<i>socket</i>, ce n'est pas le cas.
</p>

<p>
Donc le problème concerne plus de comment coder le <code>refiller</code> que Decompress.
Bonne nouvelle.
</p>

<p>
Cependant, il y a tout de même une <i>infinite loop</i> bien après avec un contenu
<i>random</i>. Donc Decompress est bien trop permissif pour l'instant ce qui n'est
pas le cas de <code>zlib</code>, on est bien face à un bug.
</p>
</div>
</div>

<div id="outline-container-org0c4d83b" class="outline-2">
<h2 id="org0c4d83b"><span class="section-number-2">14</span> <span class="done DONE">DONE</span> Vérifier RFC1951 sur les derniers bytes</h2>
<div class="outline-text-2" id="text-14">
<p>
En effet, puisque RFC1951 n'est pas forcément aligné, il nous faut vérifier
proprement si on a bien écrit les derniers bytes nécessaires qui devrait se
retrouver dans <code>hold</code> (et signaler à l'utilisateur combien de bits sont libres).
</p>
</div>
</div>

<div id="outline-container-orgec8874b" class="outline-2">
<h2 id="orgec8874b"><span class="section-number-2">15</span> <span class="done DONE">DONE</span> Vérifier le <i>header</i> dans decompress</h2>
<div class="outline-text-2" id="text-15">
</div>
</div>

<div id="outline-container-orgc87e927" class="outline-2">
<h2 id="orgc87e927"><span class="section-number-2">16</span> Fuzzer encore</h2>
<div class="outline-text-2" id="text-16">
</div>
<div id="outline-container-org345a7e3" class="outline-3">
<h3 id="org345a7e3"><span class="section-number-3">16.1</span> Il faut attendre la <a href="https://github.com/stedolan/crowbar/pull/36">PR de Gabriel</a> pour faire ce travail.</h3>
</div>
</div>

<div id="outline-container-org6ec987d" class="outline-2">
<h2 id="org6ec987d"><span class="section-number-2">17</span> <span class="todo TODO">TODO</span> Optimiser ocaml-git</h2>
<div class="outline-text-2" id="text-17">
</div>
<div id="outline-container-org1ffe2e5" class="outline-3">
<h3 id="org1ffe2e5"><span class="section-number-3">17.1</span> <span class="done DONE">DONE</span> Utiliser <code>Hashtbl</code> à la place de <code>Map</code></h3>
<div class="outline-text-3" id="text-17-1">
</div>
</div>
<div id="outline-container-orgad17aa0" class="outline-3">
<h3 id="orgad17aa0"><span class="section-number-3">17.2</span> <span class="done DONE">DONE</span> Revoir <code>Pack_info</code> et réutiliser son code pour l'analyze d'un flux PACK</h3>
<div class="outline-text-3" id="text-17-2">
<ul class="org-ul">
<li class="off"><code>[&#xa0;]</code> factoriser et nettoyer le code</li>
<li class="on"><code>[X]</code> renommer les fonctions disponibles en <code>first_pass</code> et <code>second_pass</code></li>
<li class="off"><code>[&#xa0;]</code> réutiliser ces fonctions dans <code>Store</code> et <code>Mem</code></li>
<li class="off"><code>[&#xa0;]</code> optimiser ces <i>pass</i></li>
<li class="on"><code>[X]</code> optimiser l'accès aux <i>meta-data</i> d'une <i>entry</i> d'un fichier PACK</li>
<li class="on"><code>[X]</code> refaire la première <i>pass</i> (aggréger objets delta-ifiés et non delta-ifié)</li>
<li class="on"><code>[X]</code> refaire la deuxième <i>pass</i> (résoudre tout les objets delta-ifiés)</li>
<li class="on"><code>[X]</code> <p>
refaire la troisième <i>pass</i> (génération d'un nouveau fichier PACK non-<i>thin</i>)
</p>

<p>
Sur ce dernier point, il me semble que obtenir la taille de l'objet était
plus long pour un objet delta-ifié puisqu'on attendait un état au décodeur
Hunk se qui impliquait qu'on commence (et même qu'on termine) la
décompression de l'<i>entry</i>. Bref, ce n'est plus le cas maintenant.
</p></li>
</ul>

<p>
Bon il faut mettre un peu à plat la logique des PACKs.
</p>

<p>
Il y a 2 façon de trouver un fichier PACK dans un dépôt git:
</p>
<ul class="org-ul">
<li>Il est déjà présent dans le dépôts — dans ce cas, aucune analyze n'est faite,
mais on a le fichier IDX disposible (normalement)</li>
<li>Il est obtenu par le réseau — on a pas de fichier IDX mais pendant la
transmission, on peut y faire une première analyze</li>
</ul>

<p>
Il faut bien dissocier les deux manières pour comprendre leurs évolutions.
Finalement, dans le <code>Pack_engine</code>, on peut dissocier 4 états:
</p>

<ul class="org-ul">
<li>le fichier PACK existes (avec un fichier IDX)</li>
<li>le fichier PACK est chargé (ainsi que son fichier IDX)</li>
<li>le fichier PACK est chargé (ainsi que son fichier IDX) et on a déjà fait une
première <i>pass</i></li>
<li><p>
le fichier PACK est chargé, le fichier IDX n'est plus chargé, on a traité tout
les objets → on a une <code>Hashtbl</code> équivalente au fichier IDX (et, sur la
vitesse, il est préférable d'utiliser cette dernière)
</p>

<p>
On sait aussi (puisqu'on a résolu tout les objets) si le PACK est <i>thin</i> ou pas
</p></li>
<li>on a tout les éléments pour extraire n'importe qu'elle objet du fichier PACK
et on sait (ou on a fait en sorte que) il n'est pas <i>thin</i></li>
</ul>

<p>
Dans le dernier cas, on est certains de pouvoir extraire TOUT les objets du
fichier PACK sans AUCUNE allocation (puisqu'elles ont été faite au préalable).
</p>

<p>
Arriver à cette situation à cependant un coup comme c'est le cas dans la version
courante d'<code>ocaml-git</code>. Il faut en gros extraire tout les objets du fichier PACK
pour ensuite être certain de la situation et promouvoir l'état au dernier
status. On peut déterminer 2 (voir 3) phases:
</p>

<ul class="org-ul">
<li><p>
La première consiste à décompresser (seulement) les objets qui ne sont pas
delta-ifiés et d'aggréger hash et <i>checksum</i> de ces objets dans une <code>Hashtbl</code>.
</p>

<p>
Cette phase permet aussi de connaître le <b>possible</b> <i>path</i> de delta-ification
(qui, dans le cas le plus commun, correspond au vrai <i>path</i>). Je veux dire
quoi par là. Un objet delta-ifié pointe forcément sur un objet (OBJ<sub>REF</sub><sub>DELTA</sub>
ou OBJ<sub>OFS</sub><sub>DELTA</sub>). Normallement, cette source ce trouve <b>avant</b> le dit objet.
</p>

<ul class="org-ul">
<li>Dans le cas d'OBJ<sub>OFS</sub><sub>DELTA</sub>, c'est assez simple de reconstruire la chaîne et
de dire que le dit objet à besoin d'une application avec l'objet source qui
est <b>déjà</b> présent dans notre <code>Hashtbl</code> qui fait office de fichier IDX
partiel. Dans ce cas, on considère que sa profondeur est celle de l'objet
source + 1 (cette dernière ayant <b>déjà</b> été calculé).</li>

<li><p>
Dans le cas d'OBJ<sub>REF</sub><sub>DELTA</sub>, c'est plus compliqué. Il peut arrivé qu'on ait
déjà traiter une <b>base</b> (donc qui n'est pas delta-ifié) ayant le hash
référencé. Cependant, rien ne nous assure que ça soit bien le cas - et la
documentation est putain de pas clair sur ça.
</p>

<p>
En cela, si on a de la chance, on peut considérer que la profondeur de
l'objet est de 1 (vu qu'on ne pourra pas aller plus loin dans la
delta-ification - peut être que l'objet source est lui même delta-ifié mais
si c'est le cas, dans la première <i>pass</i>, on le retrouvera pas vu qu'on aura
pas son hash, c'est pour cette raison que le note comme étant <code>Unresolved</code>).
</p>

<p>
Dans le pire cas, cela reste une mystère.
</p></li>
</ul>

<p>
Ainsi, dans cette <i>pass</i>, on a une vu partiel qui peut aider à limiter les
allocations nécessaires pour extraire les objets du fichier PACK mais on ne
pourra pas les limiter. L'idée est donc de <i>s'aider</i> des paths calculés pour
donner une allocation <b>partielle</b> nécessaire au stockage des <code>hunks</code>.
</p>

<p>
NOTE: La fonction <code>get</code> de <code>Unpack</code> attends donc à ce que chaque niveau soient
bien calculés mais qu'il n'est pas nécessaire d'avoir tout les niveaux.
</p></li>

<li><p>
La deuxième consiste à ce qu'on ait résolu tout les objets delta-ifié ce qui
veut dire que tout les <i>paths</i> devrait être tout résolus - à chaque fois qu'on
extrait un objet, on obtient aussi son <i>path</i> résolu.
</p>

<p>
En cela, on peut savoir l'allocation nécessaire pour chaque niveau pour les
<i>hunks</i> premièrement et et on peut aussi savoir si le PACK est <i>thin</i> ou pas -
c'est à dire si il demande un objet extérieur ou pas.
</p>

<p>
Dans le cas où il n'est pas <i>thin</i>, on est dans la situation où on sait
exactement ce qu'on a besoin pour extraire tout les objets. Si il est <i>thin</i>,
puisqu'il y a un (ou plusieurs) objet extérieur au PACK requis pour la
reconstruction d'un ou plusieurs objets, il s'agira forcément d'allouer cet
objet (je parle d'allocation puisqu'on devra forcément avoir des buffers
extérieurs au scope des buffers qui sont déjà utilisés) pour reconstruire
finalement l'objet cible.
</p></li>

<li>Et la troisième phase enfin consiste à re-<i>packer</i> le fichier PACK pour qu'il
ne soit plus <i>thin</i>.</li>
</ul>

<p>
Donc avec 2 <i>entry point</i>, 5 états et 3 <i>pass</i>, je pense qu'on est bon au niveau
de la granularité du traitement des fichiers PACK. Cela semble carrément
compliqué mais il faut aussi saisir que ce n'est pas dans cette logique que
fonctionne <code>git</code> (qui reste un utilitaire de commande qui ne cherche pas à gérer
dans un contexte <code>memory bounded</code> l'extraction des objets).
</p>
</div>
</div>

<div id="outline-container-org9c1ca87" class="outline-3">
<h3 id="org9c1ca87"><span class="section-number-3">17.3</span> <span class="done DONE">DONE</span> Optimization des fichiers PACK déjà disponibles dans le dépôts</h3>
<div class="outline-text-3" id="text-17-3">
<p>
NOTE: une petite illumination sur la gestion du fichier PACK. En effet, lorsque
le fichier PACK est présent dans le dépôts (donc le premier <i>entry point</i>), on
peut présupposer qu'il y a aussi le fichier IDX. Dans ce cas, lors de notre
première <i>pass</i>, on peut résoudre tout les <i>path</i>.
</p>

<p>
En effet, ce qui casse les <i>path</i> est spécifiquement OBJ<sub>REF</sub><sub>DELTA</sub> puisqu'on a
pas calculer tout les hashes du dit fichier PACK. Cependant, le fichier IDX
associé peut nous aider à savoir si le hash spécifié par OBJ<sub>REF</sub><sub>DELTA</sub> est dans
le fichier PACK ou non.
</p>

<p>
En sachant ça, on peut mettre savoir la position absolue de la source et
continuer à construire le <i>path</i>. En cela, en une seule <i>pass</i>, on peut calculer
le <i>path</i> de delta-ification de tout les objets (quand bien même ils utilise
OBJ<sub>REF</sub><sub>DELTA</sub> ou pas), savoir si le fichier PACK est <i>thin</i> (dans le cas où un
OBJ<sub>REF</sub><sub>DELTA</sub> n'est pas référencé par le fichier IDX) ou pas et passer
directement au <i>state</i> <code>Resolved</code>.
</p>

<p>
Bien entendu, il faut faire cette <i>pass</i> (et donc lire la totalité du fichier
PACK) ce qui n'est pas forcément ce que souhaite un utilisateur dans un contexte
<i>client</i>. Cependant, cela élude la question de la promotion des états pour un
fichier PACK présent qui, au pire (et encore, avoir un fichier PACK <i>thin</i> déjà
disponible dans le dépôts n'est pas autorisé), doit passer par 2 <i>pass</i> (la
première et la troisième pour passer d'un PACK <i>thin</i> à un PACK non-<i>thin</i>).
</p>


<p>
Le code est disponibke <a href="https://github.com/mirage/ocaml-git/pull/292">ici</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-org6d024ed" class="outline-2">
<h2 id="org6d024ed"><span class="section-number-2">18</span> <span class="todo TODO">TODO</span> Trouver pourquoi on avait pas trouver le bug par rapport aux \000 dans les noms dans les trees</h2>
</div>
<div id="outline-container-org425eb28" class="outline-2">
<h2 id="org425eb28"><span class="section-number-2">19</span> <span class="todo TODO">TODO</span> Extraire la partie qui sérialize une seule <i>entry</i> dans l'implémentation du PACK</h2>
</div>
<div id="outline-container-org9445d7d" class="outline-2">
<h2 id="org9445d7d"><span class="section-number-2">20</span> <span class="todo TODO">TODO</span> Permettre d'encoder une seule <i>entry</i> pour <code>wodan</code></h2>
</div>
<div id="outline-container-org03bbf61" class="outline-2">
<h2 id="org03bbf61"><span class="section-number-2">21</span> <span class="todo TODO">TODO</span> Faire le serveur</h2>
<div class="outline-text-2" id="text-21">
<ul class="org-ul">
<li class="off"><code>[&#xa0;]</code> Fuzzer l'encoder et le décoder Smart</li>
<li class="off"><code>[&#xa0;]</code> Faire le moteur de négociation</li>
<li class="off"><code>[&#xa0;]</code> Faire une abstraction du serveur (TCP pour l'instant)</li>
</ul>
<p>
Implémenter un <i>call-by-need</i> dans ocaml-git
</p>

<p>
L'idée est de ne pas obtenir l'objet Git dès qu'on souhaite juste le manipuler
(<code>Value.t</code>) mais de l'obtenir seulement quand on souhaite accéder à une
information à l'intérieur (comme <code>Value.Commit.tree</code>).
</p>

<p>
On peut imaginer cette définition:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span class="org-tuareg-font-lock-governing">type</span> <span class="org-keyword">lazy</span> <span class="org-tuareg-font-lock-operator">=</span>
  <span class="org-tuareg-font-lock-operator">|</span> <span class="org-tuareg-font-lock-constructor">Pack</span> <span class="org-keyword">of</span> <span class="org-tuareg-font-lock-operator"><span class="org-rainbow-delimiters-depth-1">{</span></span> hash <span class="org-tuareg-font-lock-operator">:</span> <span class="org-tuareg-font-lock-module">Hash.</span>t<span class="org-tuareg-font-lock-operator">;</span> offset <span class="org-tuareg-font-lock-operator">:</span> int64 <span class="org-tuareg-font-lock-operator"><span class="org-rainbow-delimiters-depth-1">}</span></span> <span class="org-comment-delimiter">(* </span><span class="org-comment">identifiant du PACK et son offset dans le dit-PACK </span><span class="org-comment-delimiter">*)</span>
  <span class="org-tuareg-font-lock-operator">|</span> <span class="org-tuareg-font-lock-constructor">Loose</span>
<span class="org-tuareg-font-lock-governing">and</span> <span class="org-variable-name">t</span> <span class="org-tuareg-font-lock-operator">=</span>
  <span class="org-tuareg-font-lock-operator">|</span> <span class="org-tuareg-font-lock-constructor">Loaded</span> <span class="org-keyword">of</span> <span class="org-tuareg-font-lock-operator"><span class="org-rainbow-delimiters-depth-1">[</span></span> <span class="org-tuareg-font-lock-constructor">`Commit</span> <span class="org-keyword">of</span> <span class="org-tuareg-font-lock-module">Commit.</span>t <span class="org-tuareg-font-lock-operator">|</span> <span class="org-tuareg-font-lock-operator">...</span> <span class="org-tuareg-font-lock-operator"><span class="org-rainbow-delimiters-depth-1">]</span></span>
  <span class="org-tuareg-font-lock-operator">|</span> <span class="org-tuareg-font-lock-constructor">Unloaded</span> <span class="org-keyword">of</span> <span class="org-keyword">lazy</span>
</pre>
</div>

<p>
Bon après, je sais pas (et je pense pas) que cela soit vraiment efficace. On est
déjà dans une politique <i>call-by-need</i> dans le sens où on charge les objets
seulement quand on les demande explicitement.
</p>

<p>
Ici, il s'agit d'affiner un peu plus le <i>call-by-need</i> et de faire les
opérations nécessaires seulement quand on souhaite non seulement obtenir l'objet
mais aussi obtenir les informations qu'il contient - maintenant est ce que ce
n'est pas déjà le cas ?
</p>

<p>
Le retour de Thomas: Il voudrait raffiner le parser en collectant les
informations non pas d'un block comme c'est le cas mais petit à petit. On
pourrait s'en sortir avec <code>Angstrom</code> en splittant le parser en plusieurs
morceaux et en modifiant l'interface <code>Commit.D</code> pour notifier dès qu'on a
décoder le <code>tree</code> (puisque c'est spécifiquement celui ci qui nous intéresse) et
garder l'état du parser pour le faire continuer si l'utilisateur demande plus
d'informations.
</p>

<p>
Il est vrai que dans le format du commit, le <code>tree</code> est la première information
et on a ensuite les parents - qui sont toutes les deux des informations
relatives au parcours du DAG. Donc on peut imaginer que cela puisse être
intéressant - on évite notamment de décompresser au meilleur des cas les autres
valeurs et le message.
</p>

<p>
Bref, il faudrait s'intéresser à la question mais elle serait spécifique en
réalité au <code>Commit</code>, répercuter le code sur les <code>Blob</code> n'a pas de sens par
exemple.
</p>
</div>
</div>

<div id="outline-container-orgb7fae00" class="outline-2">
<h2 id="orgb7fae00"><span class="section-number-2">22</span> <span class="todo TODO">TODO</span> Regarder mirage-lambda et y participer</h2>
</div>

<div id="outline-container-org5bdffc3" class="outline-2">
<h2 id="org5bdffc3"><span class="section-number-2">23</span> Passer Mr. MIME à Angstrom</h2>
<div class="outline-text-2" id="text-23">
<p>
J'ai eu une idée de GADT.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span class="org-tuareg-font-lock-governing">type</span> <span class="org-type">'a field</span>
  <span class="org-tuareg-font-lock-operator">|</span> <span class="org-tuareg-font-lock-constructor">Content_type</span> <span class="org-tuareg-font-lock-operator">:</span> content_type field
  <span class="org-tuareg-font-lock-operator">|</span> <span class="org-tuareg-font-lock-constructor">Msg_id</span> <span class="org-tuareg-font-lock-operator">:</span> msg_id field

<span class="org-tuareg-font-lock-governing">type</span> <span class="org-type">res</span> <span class="org-tuareg-font-lock-operator">=</span>
  <span class="org-tuareg-font-lock-operator"><span class="org-rainbow-delimiters-depth-1">[</span></span> <span class="org-tuareg-font-lock-constructor">`Await</span> <span class="org-keyword">of</span> decoder
  <span class="org-tuareg-font-lock-operator">|</span> <span class="org-tuareg-font-lock-constructor">`Header</span> <span class="org-keyword">of</span> <span class="org-tuareg-font-lock-operator"><span class="org-rainbow-delimiters-depth-2">(</span></span>'v field<span class="org-tuareg-font-lock-operator">,</span> 'v<span class="org-tuareg-font-lock-operator"><span class="org-rainbow-delimiters-depth-2">)</span></span>
  <span class="org-tuareg-font-lock-operator">|</span> <span class="org-tuareg-font-lock-constructor">`End</span> <span class="org-tuareg-font-lock-operator"><span class="org-rainbow-delimiters-depth-1">]</span></span>
</pre>
</div>

<p>
En gros, le décodeur va s'arrêter à chaque <i>fields</i> de l'e-mail et donner sa
valeur. Ce sera super bien typé grâce au GADT <code>field</code>. Il suffira d'une fonction
<code>continue</code> pour passer au <code>field</code> suivant ou au <code>body</code>. Cependant, la question
du <code>body</code> (entre <code>multipart/alternate</code> ou simple <code>multipart</code>) ce pose toujours.
</p>
</div>
</div>

<div id="outline-container-org5d14f78" class="outline-2">
<h2 id="org5d14f78"><span class="section-number-2">24</span> Gérer l'<i>encoding</i> des e-mails (normaliser un <i>encoding</i> vers de l'UTF-8)</h2>
<div class="outline-text-2" id="text-24">
<p>
Camomile fait déjà le <i>mapping</i> entre les <i>encodings</i> et l'unicode. Cependant,
en regardant le code, c'est à la fois complexe, redondant et certainements
inutiles. Un simple exemple, la structure permettant de mapper un code d'un
encoding vers un autre est implémenter dans <code>Tbl31</code>: le code est juste immonde -
un patricia tree suffirait largement (bien entendu, il faudrait faire des
benchmarks mais on y gagnerais en lisibilité).
</p>

<p>
Bon selon dbuenzli, Camomile supporterait que unicode 3 et dépends de fichiers
externes. Deux erreurs qu'il ne faudrait pas reproduire.
</p>
</div>

<div id="outline-container-orgd6dfa14" class="outline-3">
<h3 id="orgd6dfa14"><span class="section-number-3">24.1</span> Faire un outil d'importation des tables de mappings entre <i>charset</i> et unicode</h3>
<div class="outline-text-3" id="text-24-1">
<ul class="org-ul">
<li class="trans"><code>[-]</code> outil d'importation des tables ISO8859
<ul class="org-ul">
<li class="on"><code>[X]</code> Extraire les informations des tables</li>
<li class="off"><code>[&#xa0;]</code> Extraire les auteurs</li>
</ul></li>
<li class="off"><code>[&#xa0;]</code> outil d'importation des tables VENDORS</li>
</ul>

<p>
Il semble que ISO8859 partage le même format pour le <i>mapping</i> (format A). Il
semnle aussi que les VENDORS, eux, ne partagent pas spécifiquement le même
format dans le <i>header</i> et les valeurs n'ont pas forcément pas la même
représentation.
</p>

<p>
On peut faire un lexer/parser qui puisse accepter les différents formats.
Cependant, extraire les informations comme le nom, la date ou encore les auteurs
semble être plus difficile.
</p>
</div>
</div>
</div>

<div id="outline-container-org5b1c1d0" class="outline-2">
<h2 id="org5b1c1d0"><span class="section-number-2">25</span> <span class="todo TODO">TODO</span> Ce forcer à utiliser org-mode (2 mois de tests)</h2>
</div>

<div id="outline-container-orgdfb421a" class="outline-2">
<h2 id="orgdfb421a"><span class="section-number-2">26</span> <span class="todo TODO">TODO</span> Avoir deux serveur uDNS (un sur intel et un sur arm) et configurer son PC sur ces serveur</h2>
<div class="outline-text-2" id="text-26">
<p>
Ce qui est compliqué, c'est que les ressources pour utiliser udns sont
inexistante et il faut pousser hannes pour faire un tutoriel.
</p>
</div>
</div>

<div id="outline-container-orgbd82e28" class="outline-2">
<h2 id="orgbd82e28"><span class="section-number-2">27</span> Implémenter Lwt<sub>sequence</sub> avec CFML ou Why3 pour ocaml-tcpip</h2>
<div class="outline-text-2" id="text-27">
<p>
Lwt<sub>sequence</sub> va devenir obsolète, cela peut donc être une bonne opportunité de
passer à du code prouvé
</p>

<p>
Un papier de Filliâtre (de 2003, hal-00789533) infirme la possibilité de prover
une liste doublement chaînée avec Why3. Il faudrait donc se tourner vers CFML -
les ressources sont moins accessibles cependant.
</p>
</div>
</div>

<div id="outline-container-orgabb8858" class="outline-2">
<h2 id="orgabb8858"><span class="section-number-2">28</span> <span class="done DONE">DONE</span> Exporter les parsers d'Emile</h2>
<div class="outline-text-2" id="text-28">
<p>
Dans mon implémentation des fichiers <i>database</i> des charset avec l'unicode, il
est nécessaire (pour éviter la duplication de code) que d'exporter les parsers
d'emile.
</p>
</div>
</div>

<div id="outline-container-org7f48f79" class="outline-2">
<h2 id="org7f48f79"><span class="section-number-2">29</span> <span class="done DONE">DONE</span> Meilleur documentation pour Emile</h2>
<div class="outline-text-2" id="text-29">
</div>
</div>
<div id="outline-container-org54f09cf" class="outline-2">
<h2 id="org54f09cf"><span class="section-number-2">30</span> <span class="todo TODO">TODO</span> Fixer <code>quoted_string</code> (Emile)</h2>
</div>
<div id="outline-container-org2beac92" class="outline-2">
<h2 id="org2beac92"><span class="section-number-2">31</span> <span class="done DONE">DONE</span> Faire une issue sur <a href="https://github.com/inhabitedtype/bigstringaf">bigstringaf</a> pour connaitre et déblayer la situation avec <code>Cstruct</code> spécifiquement</h2>
<div class="outline-text-2" id="text-31">
<p>
Bon c'est une issue un peu délicate où il s'agit de comprendre la situation de
chacun par rapport au problème initial qu'est le module <code>Bigarray</code>. En soit, la
vrai question est de savoir si <code>bigstringaf</code> devrait remplacer <code>Cstruct.t</code>,
avoir un support pour MirageOS, et porter les différentes besoins par rapport à
<code>Bigarray</code>. La liste est celle-ci:
</p>
</div>

<div id="outline-container-org57dd53d" class="outline-3">
<h3 id="org57dd53d"><span class="section-number-3">31.1</span> Implémentation C (utilisant <code>memcpy</code> et/ou <code>memmove</code>).</h3>
<div class="outline-text-3" id="text-31-1">
<p>
La situation est que <code>Bigarray</code> utilise <code>memmove</code>. <code>Cstruct</code> peut ne pas
correspondre puisque de <code>Bigarray</code> vers <code>Bigarray</code>, il utilise <code>memmove</code>
(<code>Decompress</code> requiert la sémantique de <code>memcpy</code>, qu'importe si c'est un
<code>Bigarray</code> ou une <code>String</code>).
</p>

<p>
<a href="https://github.com/yallop/ocaml-memcpy">ocaml-memcpy</a> par @yallop propose déjà cette implémentation dirigé par
<code>ocaml-ctypes</code> ce qui ne le rends pas forcément favorable au niveau des petites
librairies comme <code>Angstrom</code> et <code>Decompress</code>.
</p>

<p>
La question est pourtant difficile puisque une implémentation en C demande à ce
qu'elle fonctionne sur MirageOS et si nous pouvions éviter du code C, ce serait
pas mal (ce que fait <code>Decompress</code>). Même si cela reste du code trivial, le
diable se cache dans les détails.
</p>
</div>
</div>

<div id="outline-container-org95c9790" class="outline-3">
<h3 id="org95c9790"><span class="section-number-3">31.2</span> Implémentation en OCaml</h3>
<div class="outline-text-3" id="text-31-2">
<p>
C'est l'option prise par <code>Decompress</code>. Bien entendu, il y a un impact sur les
performances mais des différents benchmarks que j'ai fait, ce n'est pas le
premier problème concernant <code>Decompress</code> (qui concerne plus le calcul Adler-32).
</p>

<p>
Pour <code>Angstrom</code>, bien entendu (et il me semble qu'il y a un <i>benchmark</i>),
l'exécution devrait être plus rapide et dans le contexte majoritaire où
<code>Angstrom</code> se retrouvé à utiliser <code>blit</code> (et donc <code>memmove~/~memcpy</code>) était pour
passer d'un input (qui maintenant est contraint à être un <code>Bigarray</code>) vers une
<code>string</code>. Dans l'implémentation de <code>Cstruct</code>, dans ce cas précis, il est utilisé
<code>memcpy</code> avec du code C.
</p>

<p>
Cependant, la question à propos de MirageOS a déjà été réglé sur cette
librairie. La question est donc de savoir pourquoi il y a eu un changement
depuis <code>Cstruct</code> vers un <i>stuff</i> interne, puis, ensuite vers <code>bigstringaf</code>. Bien
entendu, ceci devrait être en rapport avec les performances.
</p>
</div>
</div>

<div id="outline-container-orga9d268f" class="outline-3">
<h3 id="orga9d268f"><span class="section-number-3">31.3</span> Bound-check</h3>
<div class="outline-text-3" id="text-31-3">
<p>
Une critique pourtant qui s'applique à <code>Cstruct</code> est le <i>bound-check</i>. De mon
point de vue, il est nécessaire même dans des contextes où on peut être sûr que
le <i>bound-check</i> ne soit pas nécessaire. Je préfère échouer que de corrompre
l'information.
</p>

<p>
Le coût du <i>bound-check</i> n'a jamais vraiment été démontré (aucune trace de
<i>benchmark</i> pour <code>Angstrom</code>). Cela vaut vraiment le coût ? Une question sans
réponse.
</p>
</div>
</div>

<div id="outline-container-org50031ff" class="outline-3">
<h3 id="org50031ff"><span class="section-number-3">31.4</span> Disgression</h3>
<div class="outline-text-3" id="text-31-4">
<p>
Il y a bien entendu la question avec <code>js_of_ocaml</code> et <code>bucklescript</code>. Mais
flemme, <code>Cstruct</code> à un support de <code>js_of_ocaml</code> mais pas de <code>bucklescript</code>. Le
reste des librairies n'en n'ont pas.
</p>
</div>
</div>

<div id="outline-container-org6f0688f" class="outline-3">
<h3 id="org6f0688f"><span class="section-number-3">31.5</span> Conclusion</h3>
<div class="outline-text-3" id="text-31-5">
<p>
Il ne s'agit pas d'être bêtement contre <code>bigstringaf</code> mais de faire un état des
lieux et de choisir le meilleur pour tout le monde. Je serais ravi qu'il n'y est
qu'une seule librairie qui fasse correctement le boulot. 
</p>

<p>
Cependant, la question ne peut pas être prise à la légère et si <code>bigstringaf</code>
devait remplir cette tâche, il lui incombe d'avoir non seulement un support pour
les différents cas (spécialement à propos de MirageOS).
</p>

<p>
Ce que je veux dire, c'est <code>bigstringaf</code> ne serait pas uniquement de la volonté
d'<code>Angstrom</code> et que cette dernière devrait s'occuper d'un plus large rôle (et
cela rajouterais des responsabilités). Bref, c'est surtout trouver une solution
qui puisse convenir et si choisir <code>bigstringaf</code> comme librairie de base pour des
plus gros projets (comme <code>ocaml-git</code>) est sans risque.
</p>

<p>
Bon on peut dire que le problème est réglé avec <a href="https://github.com/inhabitedtype/bigstringaf/pull/10">cette PR</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgee9fdf9" class="outline-2">
<h2 id="orgee9fdf9"><span class="section-number-2">32</span> <span class="todo TODO">TODO</span> refaire <code>callypige</code> <b>URGENT</b></h2>
<div class="outline-text-2" id="text-32">
<p>
Le code C vient de Google et est sous licence BSD-3. On peut donc l'importer
dans un paquet opam en gardant bien le <i>header</i>. L'idée est de faire comme
<code>digestif</code> est proposé une implémentation en C et en OCaml - le code OCaml
devrait être hyper lent vu qu'on utiliser <code>Int64</code>.
</p>

<p>
Sinon, @samoht conseille de proposer une génération pseudo-automatique de
<i>curve25519</i> par <code>coq-fiat</code> et d'en faire un paquet. J'étais plutôt dans l'idée
d'instrumentaliser <code>coq-fiat</code> dans un autre projet (<i>punto</i>) pour être à jour
mais cela semble être un peu <i>overkill</i> (sur l'installation, on dépendra de
<code>coq</code> et la génération semble être très coûteuse).
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Calascibetta</p>
<p class="date">Created: 2018-04-30 lun. 22:47</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>